#+TITLE: bash config
#+PROPERTY: header-args  :results silent :tangle ../../dots/bash/.bashrc :mkdirp yes
* Start
** Disable ctrl-s/ctrl-q
#+BEGIN_SRC sh
stty -ixon # Disable ctrl-s and ctrl-q.
#+END_SRC
** Auto cd
#+BEGIN_SRC sh
shopt -s autocd #Allows you to cd into directory merely by typing the directory name.
#+END_SRC
** History Size
#+BEGIN_SRC sh
HISTSIZE= HISTFILESIZE= # Infinite history.
#+END_SRC
** Bash Prompt
#+BEGIN_SRC sh
# Setting Bash prompt. Capitalizes username and host if root user (my root user uses this same config file).
if [ "$EUID" -ne 0 ]
	then export PS1="\[$(tput bold)\]\[$(tput setaf 1)\][\[$(tput setaf 3)\]\u\[$(tput setaf 2)\]@\[$(tput setaf 4)\]\h \[$(tput setaf 5)\]\W\[$(tput setaf 1)\]]\[$(tput setaf 7)\]\\$ \[$(tput sgr0)\]"
	else export PS1="\[$(tput bold)\]\[$(tput setaf 1)\][\[$(tput setaf 3)\]ROOT\[$(tput setaf 2)\]@\[$(tput setaf 4)\]$(hostname | awk '{print toupper($0)}') \[$(tput setaf 5)\]\W\[$(tput setaf 1)\]]\[$(tput setaf 7)\]\\$ \[$(tput sgr0)\]"
fi
#+END_SRC
** GPG-agent
#+BEGIN_SRC sh
export GPG_TTY=$(tty)
#+END_SRC
** VIM Mode
#+BEGIN_SRC sh
set -o vi
#+END_SRC
** PATH
#+BEGIN_SRC sh
export PATH="$(du $HOME/.scripts/ | cut -f2 | tr '\n' ':')$PATH":"~/.emacs.d/bin":"~/.gem/ruby/2.5.0/bin"
#+END_SRC
** Colorls
#+BEGIN_SRC sh
source $(dirname $(gem which colorls))/tab_complete.sh
#+END_SRC
** Pywal Colors
#+BEGIN_SRC sh
. "${HOME}/.cache/wal/colors.sh"
#+END_SRC
* Shortcuts
#+BEGIN_SRC sh
alias h="cd ~/ && ls -a"
alias d="cd ~/Documents && ls -a"
alias D="cd ~/Downloads && ls -a"
alias m="cd ~/Music && ls -a"
alias pp="cd ~/Pictures && ls -a"
alias vv="cd ~/Videos && ls -a"
alias cf="cd ~/.config && ls -a"
alias sc="cd ~/.scripts && ls -a"
alias mn="cd /mnt && ls -a"
alias e="cd /etc && ls -a"
alias bf="$EDITOR ~/.key_files"
alias bd="$EDITOR ~/.key_directories"
alias cfb="$EDITOR ~/.bashrc"
alias cfz="$EDITOR ~/.zshrc"
alias cfv="$EDITOR ~/.vimrc"
alias cfr="$EDITOR ~/.config/ranger/rc.conf"
alias cfi="$EDITOR ~/.config/i3/config"
alias cfq="$EDITOR ~/.config/qutebrowser/config.py"
alias cfm="$EDITOR ~/.config/mutt/muttrc"
alias cft="$EDITOR ~/.config/termite/config"
alias eb="$EDITOR ~/Documents/LaTeX/uni.bib"
alias cv="$EDITOR ~/Documents/LaTeX/cv.tex"
alias cfp="$EDITOR ~/.config/polybar/config"
alias cfd="$EDITOR ~/.Xdefaults"
alias cfu="$EDITOR ~/.config/newsboat/urls"
alias cfn="$EDITOR ~/.config/newsboat/config"
alias cfA="$EDITOR ~/.asoundrc"
alias cfmb="$EDITOR ~/.config/ncmpcpp/bindings"
alias cfmc="$EDITOR ~/.config/ncmpcpp/config"
alias cfmpd="$EDITOR ~/.config/mpd/mpd.conf"
alias cfM="$EDITOR ~/.config/mpd/mpd.conf"
alias er="$EDITOR ~/.referbib"
#+END_SRC
* Aliases
** System Maintainence
#+BEGIN_SRC sh
# System Maintainence
alias mw="~/.config/mutt/mutt-wizard.sh"
alias muttwizard="~/.config/mutt/mutt-wizard.sh"
alias progs="(pacman -Qet && pacman -Qm) | sort -u" # List programs I've installed
alias orphans="pacman -Qdt" # List orphan programs
alias sdn="sudo shutdown now"
alias psref="gpg-connect-agent RELOADAGENT /bye" # Refresh gpg
alias pacrepo='sudo reflector -l 20 -f 10 --save /etc/pacman.d/mirrorlist'
#alias pacman='sudo pacman'
alias journalctl='sudo journalctl'
alias pacu='sudo pacman -Syu --noconfirm'
#alias auru='yaourt -Syua --noconfirm'
alias aur='yay -S --noconfirm'
alias systemctl='sudo systemctl'
alias se='ls /usr/bin | grep'
#+END_SRC
** Misc
#+BEGIN_SRC sh
# Some aliases
alias vi='vim'
alias aur='yay -S --noconfirm'
alias rm='rm -ri'
alias :q='exit'
alias p="sudo pacman"
alias SS="sudo systemctl"
alias sv="sudo vim"
alias r="ranger"
alias sr="sudo ranger"
alias ka="killall"
alias g="git"
alias trem="transmission-remote"
alias mkd="mkdir -pv"
alias ref="source ~/.bashrc" # Refresh shortcuts manually and reload bashrc
alias bw="wal -i ~/.config/wall.png" # Rerun pywal
#+END_SRC
** Colors
#+BEGIN_SRC sh
# Adding color
alias lc='colorls -A --sd'
alias llc='colorls -lA --sd'
alias lgt='colorls --git-status --tree --sd'
alias lg='colorls --git-status --sd'
alias lt='colorls --tree --sd'
alias ls='ls -hN --color=auto --group-directories-first'
alias ll='ls -hNal --color=auto --group-directories-first'
alias grep="grep --color=auto" # Color grep - highlight desired sequence.
alias ccat="highlight --out-format=ansi" # Color cat - print file with syntax highlighting.
#+END_SRC
** Internet
#+BEGIN_SRC sh
# Internet
alias yt="youtube-dl --add-metadata -ic" # Download video link
alias yta="youtube-dl --add-metadata -xic" # Download only audio
alias YT="youtube-viewer"
alias ethspeed="speedometer -r enp0s25"
alias wifispeed="speedometer -r wlp2s0"
alias starwars="telnet towel.blinkenlights.nl"
#+END_SRC
** Latex
#+BEGIN_SRC sh
# TeX
alias Txa="cp ~/Documents/LaTeX/article.tex"
alias Txs="cp ~/Documents/LaTeX/beamer.tex"
alias Txh="cp ~/Documents/LaTeX/handout.tex"
#+END_SRC
** Edinburgh
#+BEGIN_SRC sh
# Edinburgh
alias check_nc="ssh s1691546@ssh.inf.ed.ac.uk -t ssh student.login -t \"./cluster_status.sh -t 5\""
alias check_n="ssh s1691546@ssh.inf.ed.ac.uk -t ssh student.login -t \"./cluster_status.sh -n -t 5\""
alias check_c="ssh s1691546@ssh.inf.ed.ac.uk -t ssh student.login -t \"./cluster_status.sh -c -t 5\""
alias atlanta="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh atlanta"
alias indianapolis="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh indianapolis"
alias philly="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh philly"
alias houston="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh houston"
alias sanantonio="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh sanantonio"
alias austin="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh austin"
alias baltimore="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh baltimore"
alias chicago="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh chicago"
alias detroit="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh detroit"
alias ottawa="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh ottawa"
alias toronto="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh toronto"
alias quebec="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh quebec"

alias uatlanta="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@atlanta"
alias uindianapolis="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@indianapolis"
alias uphilly="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@philly"
alias uhouston="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@houston"
alias usanantonio="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@sanantonio"
alias uaustin="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@austin"
alias ubaltimore="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@baltimore"
alias uchicago="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@chicago"
alias udetroit="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@detroit"
alias uottawa="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@ottawa"
alias utoronto="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@toronto"
alias uquebec="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh user@quebec"

alias mellanox1="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh admin@mellanox.inf.ed.ac.uk"
alias mellanox2="ssh -A s1691546@ssh.inf.ed.ac.uk -t -A ssh admin@mellanox2.inf.ed.ac.uk"
#+END_SRC
** QT
#+BEGIN_SRC sh
export QT_STYLE_OVERRIDE=gtk
export QT_SELECT=qt5
#+END_SRC
** Lang
#+BEGIN_SRC sh
if [[ $LANG = '' ]]; then
	export LANG=en_US.UTF-8
fi
#+END_SRC
* Fuzzy_Completion
#+BEGIN_SRC sh
# set to 0 to disable logging output
_fuzzy_debug=${_fuzzy_debug:-0}
# ignoring case slows things down a bit
_fuzzy_ignore_case=1

### First, some debugging routines ###
_fuzzy_log()
{
    [[ $_fuzzy_debug -ne 1 ]] && return
    echo $1 >> ~/.fuzzy_complete_log.txt
}

# Helper function to log the value of an array. Associative arrays are
# not supported.
_fuzzy_log_arr()
{
    local -a thearray=("${!1}")
    local k arrname=${1/'[@]'/}
    for k in ${!thearray[@]}; do
        _fuzzy_log "${arrname}[$k] is ${thearray[$k]}"
    done
}

# Helper function to log the value of a variable
_fuzzy_log_var()
{
    [[ $_fuzzy_debug -ne 1 ]] && return
    _fuzzy_log "$1 is ${!1}"
}
### End debugging routines ###

### Helpers ###
_fuzzy_upcase()
{
    echo ${1^^}
}

_fuzzy_complete_find_matches()
{
    local allfiles match_pattern target_dir
    local -a filteredfiles
    allfiles=$1
    match_pattern=$2
    if [[ $3 == "." || "$3" == "" ]]; then
        target_dir=""
    elif [[ $3 =~ ^/+$ ]]; then
        target_dir=/
    else
        target_dir="$(dirname ${3}/phoney)/"
    fi
    filteredfiles=""
    [[ $_fuzzy_ignore_case -eq 1 ]] && match_pattern=$( _fuzzy_upcase $match_pattern )
    _fuzzy_log_var match_pattern
    _fuzzy_log_var target_dir
    _fuzzy_log_var allfiles
    for f in $1; do
        f_t=$f
        [[ $_fuzzy_ignore_case -eq 1 ]] && f_t=$( _fuzzy_upcase $f )
        # _fuzzy_log_var f
        # _fuzzy_log_var f_t
        if [[ ${f_t} =~ $match_pattern ]]; then
            _fuzzy_log "$f (${f_t}) matches, appending..."
            newguy="${target_dir}$f"
            filteredfiles="${filteredfiles}${newguy} "
        fi
    done
    echo $filteredfiles
}
### End Helpers ###

### The main completion routine ###
_fuzzy_complete()
{
    local files cur prev target_dir target_word filteredfiles allfiles match_pattern tails cnt tmp
    # Available variables:
    # COMP_LINE COMP_POINT COMP_KEY COMP_TYPE COMP_WORDS COMP_CWORD
    # $1 : name of command whose arguments are being completed
    # $2 : the word being completed
    # $3 : the word preceding the word being completed
    _get_comp_words_by_ref cur prev
    # cur="$2"
    # prev="$1"

    # if they're expanding a variable get out of here:
    if [[ ${cur:0:1} == '$' ]]; then
        COMPREPLY=""
        return 1
    fi

    if [[ -d $cur ]]; then
        # hack to deal with trailing spaces and such: use dirname with
        # a phoney basename. We might be adding an extra / but dirname
        # deals with all that. However, if $cur is just `/', then
        # basename leaves a `trailing slash' (it's the only slash,
        # leading and trailing).
        if [[ $cur =~ ^/+$ ]]; then
            _fuzzy_log "rooting around"
            target_dir=/
        else
            target_dir=$(dirname "$cur/phoney")
        fi
        target_word=""
    else
        target_dir=$(dirname $cur)
        target_word=$(basename $cur | tr -d -C '[a-zA-Z0-9_\-]')
    fi
    # make sure everything (like ~) is expanded:
    eval target_dir=$target_dir
    _fuzzy_log_var target_dir
    _fuzzy_log_var target_word

    # default match pattern is .* between every letter:
    match_pattern=""
    for (( i=0; i < ${#target_word}; i++ )); do
        # append the ith character to the match pattern along with another .*
        match_pattern="${match_pattern}.*${target_word:${i}:1}"
    done
    # trailing .*
    match_pattern="${match_pattern}.*"
    _fuzzy_log_var match_pattern

    if [[ ! -d $target_dir ]]; then
        _fuzzy_log "$target_dir is not a dir"
        COMPREPLY=""
        return 1
    fi


    allfiles=$( command ls -B $target_dir )
    _fuzzy_log_var allfiles
    filteredfiles=( $( _fuzzy_complete_find_matches "$allfiles" "$match_pattern" "$target_dir" ) )
    # _fuzzy_log_arr filteredfiles[@]
    COMPREPLY=( ${filteredfiles[@]} )
    _fuzzy_log ""               # some logfile spacing
    # COMPREPLY=( $filteredfiles )
}
### End main completion routine ###




################################################################################
# From here down:
# fuzzy_setup_functions - a set of functions to facilitate setting
# up fuzzy completion
################################################################################

declare -A _fuzzy_replaced_specs

# the options used to set up the completion:
_fuzzy_complete_options="-o bashdefault -o default -o filenames -o nospace -v -F _fuzzy_complete"

# function _fuzzy_find_compspec_by_pattern
#
# find existing compspec by regex pattern
#
# params :
# 1      : the regex to search for (e.g. " -F _filedir_xspec")
#
# return values :
#  - echo       : the compspec
#  - return     : 0 on success, 1 on failure
_fuzzy_find_compspec_by_pattern()
{
    local the_pattern="$1"
    complete | {
        while read myline; do
            # see if the function matches
            if [[ $myline =~ $the_pattern ]]; then
                echo $myline
                return 0
            fi
        done
    }
    return 1
}

# function _fuzzy_find_compspec_by_function
#
# find existing compspec by function
#
# params :
# 1      : the function to search for (e.g. _filedir_xspec)
#
# return values :
#  - echo       : the compspec
#  - return     : 0 on success, 1 on failure
_fuzzy_find_compspec_by_function()
{
    local stuff retval
    stuff=$( _fuzzy_find_compspec_by_function " -F $1" )
    retval=$?
    echo $stuff
    return $retval
}


# function _fuzzy_find_compspec_by_command
#
# find existing compspec by command
#
# params :
# 1      : the command to search for (e.g. ls)
#
# returns   :
#  - echo   : the compspec
#  - return : 0 on success, 1 on failure
_fuzzy_find_compspec_by_command()
{
    local stuff retval
    stuff=$( _fuzzy_find_compspec_by_function "$1\$" )
    retval=$?
    echo $stuff
    return $retval
}

# function _fuzzy_re_extract_first
#
# Extracts the first match of the regex
#
# params :
# 1      : the text against which we'll test our regex
# 2      : the regex (should contain one match group)
#
# returns :
#  - echo : the matched text
_fuzzy_re_extract_first()
{
    if [[ "$1" =~ $2 ]]; then
        echo -n ${BASH_REMATCH[1]}
    fi
}

# function _fuzzy_extract_command_from_compspec
#
# Extracts the command out of a compspec (the last word in the compspec)
#
# params :
# 1      : the compspec line (e.g. "complete -o default -F _longopt mv")
#
# returns :
#  - echo : the command
_fuzzy_extract_command_from_compspec()
{
    echo -n $( _fuzzy_re_extract_first "$1" ".*( [^ ]+$)" )
}

# function _fuzzy_extract_function_from_compspec
#
# Extracts the function out of a compspec (the thing following a -F)
#
# params :
# 1      : the compspec line (e.g. "complete -o default -F _longopt mv")
#
# returns :
#  - echo : the function
_fuzzy_extract_function_from_compspec()
{
    echo -n $( _fuzzy_re_extract_first "$1" ".*-F ([^ ]+) .*" )
}


# function _fuzzy_replace_compspecs_by_function
#
# replace existing completion spec functions with _fuzzy_complete. The
# replaced compspecs are saved in _fuzzy_replaced_specs for possible
# later restoration. If no existing compspecs are found for the given
# function, nothing happens.
#
# params :
# 1      : the existing compspec function to replace
#          (something like _filedir_xspec)
_fuzzy_replace_compspecs_by_function()
{
    local existing_spec="$1" this_command this_function

    while read myline; do
        this_function=$( _fuzzy_extract_function_from_compspec "$myline" )
        [[ -n "$this_function" && $this_function == $existing_spec ]] \
            || continue
        this_command=$( _fuzzy_extract_command_from_compspec "$myline" )
        # key will look something like: "_filedir_xspec xdvi"
        _fuzzy_replaced_specs["$this_function $this_command"]="$myline"
        # set up our new completion:
        complete $_fuzzy_complete_options $this_command
        # we might have more to replace. keep going...
    done < <( complete | grep $1 )
}

# function _fuzzy_replace_compspecs_by_command
#
# sets up fuzzy completion for a specific command. If no existing
# compsec is found for the given command, the completion is still set
# up.
#
# params :
# 1      : the command for which we want to set up fuzzy completion
#          (e.g. ls)
_fuzzy_replace_compspecs_by_command()
{
    local existing_command="$1" this_command this_function
    # foreach line in the output of `complete`
    while read myline; do
        this_command=$( _fuzzy_extract_command_from_compspec "$myline" )
        [[ -n "$this_command" && $this_command == $existing_command ]] \
            || continue
        this_function=$( _fuzzy_extract_function_from_compspec "$myline" )
        # key will look something like: "_filedir_xspec xdvi"
        _fuzzy_replaced_specs["$this_function $this_command"]="$myline"
        # set up our new completion:
        complete $_fuzzy_complete_options $existing_command
        # there should only be one compspec per command, so we're done
        return
    done < <( complete | grep $1 )
    echo "No existing compspecs for ${existing_command}. Setting up new compspec."
    complete $_fuzzy_complete_options $existing_command
}

# function fuzzy_list_replaced_specs
#
# Lists all compspecs that have been replaced by the functions found
# in fuzzy_setup_functions. If you just want to see the specs
# (without all the header and footer mumbo jumbo), just redirect
# stderr to /dev/null (i.e. fuzzy_list_replaced_specs 2>/dev/null )
fuzzy_list_replaced_specs()
{
    local compspec
    echo "    All replaced compspecs:" 1>&2
    echo "==============================="  1>&2
    echo "" 1>&2
    [[ ${#_fuzzy_replaced_specs[@]} -eq 0 ]] && echo " ...None..." && return
    for compspec in "${_fuzzy_replaced_specs[@]}"; do
        echo " :: $compspec"
    done
    echo ""  1>&2
    echo "==============================="  1>&2
    echo "To restore these compspecs, use"  1>&2
    echo "fuzzy_restore_all_specs" 1>&2
}

# function fuzzy_restore_all_specs
#
# Attempts to restore any specs that have been replaced by
# _fuzzy_replace_compspecs_by_function
fuzzy_restore_all_specs()
{
    local key
    for key in "${!_fuzzy_replaced_specs[@]}"; do
        echo "restoring ${_fuzzy_replaced_specs[$key]}"
        eval ${_fuzzy_replaced_specs["$key"]}
        unset _fuzzy_replaced_specs["$key"]
    done
}

# function fuzzy_setup_for_command
#
# Sets up fuzzy completion for the given command. This function is a
# shamelessly naive frontend to _fuzzy_replace_compspecs_by_command.
#
# params :
# 1      : the command for which we want to set up fuzzy completion
fuzzy_setup_for_command()
{
    _fuzzy_replace_compspecs_by_command $1
}

# function fuzzy_setup_replace_compspec_function
#
# Sets up fuzzy completion for the given command. This function is a
# shamelessly naive frontend to _fuzzy_replace_compspecs_by_function.
#
# params :
# 1      : the compspec function we want to replace with fuzzy
fuzzy_setup_replace_compspec_function()
{
    _fuzzy_replace_compspecs_by_function $1
}

# function fuzzy_replace_filedir_xspec
#
# Replaces the _filedir_xspec compspec function that ships with the
# bash_completion package and takes care of general filedir
# completion (a good candidate for fuzzy completion!)
fuzzy_replace_filedir_xspec()
{
    fuzzy_setup_replace_compspec_function _filedir_xspec
}

#+END_SRC
